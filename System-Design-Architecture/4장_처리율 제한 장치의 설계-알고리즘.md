## 1.  토큰 버킷 알고리즘
- 처리율 제한에 가장 폭넓게 이용되는 알고리즘이다.
- 동작 원리 : 
   - 토큰 버킷이라는 지정된 용량을 갖는 컨테이너가 있고, 이 버킷에 사전에 설정한 양의 토큰이 사전에 설정한 주기마다 채워진다.
   - 각 요청을 처리할 때 마다 하나의 토큰을 사용하기 때문에, 요청이 도착하면 버킷에 토큰이 있는지 확인하고, 토큰이 없다면 해당 요청은 버려진다.
   - 토큰이 꽉 차게 되면 더 이상 토큰이 추가 되지 않는다. (토큰이 사용되면 다시 주기적으로 채워진다.)
   - 해당 알고리즘은 두개의 인자 : 용량이 4인 버킷(버킷 크기), 토큰 공급률은 분당 4개(토큰 공급률)를 받아서 설정해놓는다.
	   - 요청마다 토큰이 1개씩 사용되고, 토큰이 0개라면 요청이 버려지고 토큰이 4개 채워져있다면 버킷에 토큰이 공급되지 않는다.

그럼 '버킷'은 몇 개 정도 사용해야 할까? 다음과 같은 사례에 따라 버킷 사용 갯수도 달라진다.



## 누출(leaky bucket) 버킷 알고리즘
- 토큰 버킷 알고리즘과 유사 + 요청 처리율이 고정되어있다는 점이 다르다.
- FIFO 방식인 큐를 사용한다.
- 동작 원리 (요청 올 때마다 토큰을 없애는 게 아닌, 큐에 요청을 채우고 특정 주기마다 요청 처리)
  1. 요청 도착 시 큐가 가득 차있는지 본다. 빈 자리가 있으면 큐에 요청을 추가한다.
  2. 큐가 가득 차있는 경우 요청을 버린다.
  3. 지정된 시간마다 큐에서 요청을 꺼내 처리한다.
- 인자
	- 버킷 크기(처리될 항목들이 보관되는 큐 사이즈와 같은 값)
	- 처리율(outflow rate) : 지정된 시간 당 몇개 항목을 처리할지 지정 값(보통 초 단위)
- 장점
	- 큐의 크기가 제한되어, 메모리 사용량 측면에서 효율적
	- 고정된 처리율을 갖고 있으므로, 안정적인 출력이 필요한 경우 적합하다.
- 단점
	- 단시간에 많은 트래픽이 몰리는 경우, 큐에 오래된 요청들이 쌓이고 그로 인해 최신 요청들이 버려지게 된다. (토큰 버킷 알고리즘은 버킷에 토큰이 있기만 하면 바로 요청을 시스템에 전달한다.)
	- 두개 인자 (버킷 크기, 처리율)들을 올바르게 튜닝하기 까다로울 수 있다.




## 3. 고정 윈도 카운터 알고리즘 (fixed window counter)
- 고정된 간격의 윈도로 타임을 나눠서, 각 윈도마다 카운터(요청 단위)를 추가한다.
- 요청 접수마다 카운터의 값이 1씩 증가한다. 
- 카운터 값이 사전에 설정한 임계치에 도달하면, 새 요청은 새 윈도가 열릴 때(고정된 간격이 지날 때) 까지 버려진다.
- 예) 타임라인(간격 시간): 1초, 처리율 : 초당 3개
- 단점: 카운터는 매분마다 초기화 되는데, 만약 윈도 경계 부근(00:01:00을 기준으로 한다면, 00:00:30~00:01:30)에 일시적으로 많은 트래픽이 몰려든 다면, 1분 내 허용한 한도(5개)보다 2배로 처리하게 된다.


## 4. 이동 윈도 로깅 알고리즘
- 고정 윈도 카운터 알고리즘이 윈도 경계 부근에 트래픽이 집중되는 경우, 한계치 이상의 요청을 수행할 수 있다는 문제를 해결하는 알고리즘
- 동작원리
1. 요청(request)의 타임스탬프(timestamp)를 추적해서, 캐시에 보관한다. ex) redis의 sorted set 같은..
2. 새 요청이 올 때, 만료된 타임스탬프는 제거하고 새 요청의 타임스탬프는 로그에 추가한다.
- 만료된 타임스탬프 : 그 값이 현재 윈도의 시작 시점 이전의 값
3. 로그 크기가 허용치보다 같거나 작다면 요청을 시스템에 전달하지만 그렇지 않다면 로그에 적어두고 요청을 거부한다. (어짜피 거부하는 거 로그에 왜 적어두지??)
- 예시 (분당 2개 요청을 처리하는 시스템)
1) 요청이 1:00:01에 도착 -> 로그가 비어있으므로 타임스탬프 적고, 한계치보다 적으므로 요청이 허용된다.
2) 요청이 1:00:30에 도착 -> 아직 1분이 안지났고, 로그에 타임스탬프 적고, 한계치보다 적으므로 요청이 허용된다.
3) 요청이 1:00:50에 도착 -> 아직 1분이 안지났고, 로그에 타임스탬프 적고, 한계치보다 많으므로 요청이 거부된다.
4) 요청이 1:01:40에 도착 -> [ 1:00:40, 1:01:40 ) 범위안에 있는 요청은 1분 윈도 안에 있는 요청. 그 전의 타임스탬프 2개는 만료됐으므로 제거 후, 새 요청의 타임스탬프를 로그에 적고, 한계치보다 적으므로 요청이 허용된다.


- 장점 :  어느 순간의 윈도를 보더라도 처리율 한도를 절대 넘지 않는다.
- 단점 : 거부된 요청의 로그마저 저장해서 다수의 메모리를 사용한다.  

## 5. 이동 윈도 카운터 알고리즘
아직 정확히 이해하진 못한 것 같지만!

- (고정 윈도 카운터 + 이동 윈도 로깅) 알고리즘
- 알고리즘 구현 방법은 2가지 접근법이 있다.
- 해당 알고리즘은 직전 n분의 요청까지 고려하는 것이다.
- 현재 n분간의 요청 수 + 직전 n분간의 요청 수 * 이동 윈도와 직전 1분이 겹치는 비율
- 예) 분당 7개 요청으로 설정되어 있고, 직전 1분동안 5개의 요청이, 현재 1분동안 3개의 요청이 왔다. 그리고 현재 1분의 30% 시점에서 새로 온 요청은 *현재 윈도에 몇 개의 요청이 온 것으로 보고* 어떻게 처리되어야할까?
	- 현재 1분간의 요청 수 3 + 직전 1분간의 요청 수 5 * 이동 윈도와 직전 1분이 겹치는 비율 70% = 6.5개 
	  -> 반올림/반내림하면 7개 or 6개
	- 반내림한다면, 1개의 요청만 더 받을 수 있다.

- 장점 : 이전 시간대의 평균 처리율에 따라 현재 윈도의 상태를 계산하므로 윈도 경계 부근에 몰리는 트래픽에도 대응할 수 있다.
- 단점 : 직전 시간대에 도착한 요청이 균등하게 분포되어있다고 가정한 상태로 추정치를 계산하므로, 다소 정규하지 않다.(느슨)
	- 다행인 것은, 실험에 따르면 40억개 요청 가운데 시스템의 실제 상태와 맞지 않게 허용되거나 버려진 요청은 0.003%에 불과하다고 한다.
