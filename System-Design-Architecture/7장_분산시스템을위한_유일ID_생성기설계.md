분산 시스템에서 사용될 유일성이 보장되는 ID를 생성해야 한다.

## 1단계. 문제 이해 및 설계 범위 확정
> 요구사항 이해, 모호함 해소하는 것에 초점을 맞추며 설계 방향 정의 (대화를 통해)
1. ID는 유일해야 하고 정렬 가능해야 한다.
2. ID값은 시간의 흐름에 따라 커지지만 언제나 1씩 증가하지는 않는다.
3. 숫자로만 구성된다.
4. 시스템 규모 : 초당 10,000 ID 생성할 수 있다.

## 2단계. 개략적 설계안 제시 및 동의 구하기 
### 1. 다중 마스터 복제
- 데이터베이스의 auto_increment 기능을 활용하는 방법
- ID 값을 1씩 증가 X, 데이터베이스 서버의 수 k 씩 증가 O
- ex) 서버1 : 1,3,5,7,.. / 서버 2 : 2,4,6,8,..
- 단점 : 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다.


### 2. UUID
장점
- UUID 생성은 단순. 서버 사이 조율 필요없으므로 동기화 이슈 없음.
- 각 서버가 자신이 쓸 ID를 생성하는 구조이므로 규모 확장 쉬움.
단점
- ID 길이가 128 비트로 너무 길다. 요구사항 충족 X
- ID를 시간순 정렬 불가능
- 숫자 아닌 값이 포함될 수 있다.

### 3. 티켓 서버(ticket server)
분산된 서버 사이에서도 유일성을 보장하는 기본 키 생성하기 위한 방법이다.
- 동작 방식

티켓 서버를 중앙 집중형으로 하나만 사용하는 것
웹 서버  |  웹 서버  |  웹 서버  |  웹 서버
       모두 티켓 서버를 바라본다.
			       '티켓 서버'

장점 
- 유일성이 보장되는 only 숫자로만 구성된 ID
- 구현하기 쉬움. 중소 규모 애플리케이션에 적합

단점
- 티켓 서버가 Single-Point-of-Failure가 되버린다. 이 한개의 서버에 장애가 발생하면, 모든 시스템이 영향을 받는다.
- 티켓 서버를 여러 대 준비하게 된다면? '데이터 동기화'를 고려해야하는 문제가 발생한다.

### 4. 스노플레이크(snowflake) 접근법
ID를 바로 생성하지 않고, **divide and conquer 전략**을 먼저 적용해보자.
생성해야 하는 ID의 구조를 여러 section으로 분할하는 것이다.
우리가 생성할 64비트 ID의 구조는 아래와 같다.
|1비트|41비트|5비트|5비트|12비트|
|------|---|---|--|--|
|0|타임스탬프|데이터센터 ID|서버 ID|일련번호|

- sign bit : 나중의 쓰임새를 위해 유보. 양/음수 구별하는데 사용할 수 있다.
- timestamp : 기원 시각(epoch) 이후 몇 밀리초 경과했는지 나타낸다.
- 데이터센터 ID : 2^5 = 32개 데이터센터를 사용할 수 있다.
- 서버 ID : 데이터 센터 당 32개의 서버를 사용할 수 있다.
- 일련번호 : 각 서버에서 ID를 생성할 때마다 이 일련번호를 1씩 증가시키는데, 이 값을 1밀리초가 경과할 때마다 0으로 리셋된다.

## 3단계. 상세 설계
네번째 방법인 스노플레이크 접근법으로 상세한 설계를 진행해본다.
- 데이터센터, 서버 ID는 시스템 시작 시 결정되고, 일반적으로 운영 시에는 바뀌지 않는다.
	- 잘못 변경하게 되면 ID 충돌이 발생하므로 변경 작업 시 신중해야 한다.
- 타임스탬프, 일련번호는 생성기가 돌고 있는 중 만들어진다.

타임스탬프
- 시간이 흐름에 따라 큰 값을 가지므로 ID가 시간 순으로 정렬 가능하게 한다.
- 예) 0-0010001010100101101001101100010110101100-01010-01100-0000000000
	- 두번째 이진 표현 형태를 추출해서 십진수로 변환 : 297616116568
	- 트위터 기원 시각(epoch) 더함 : 1586~~~~ 밀리초 값
	- 밀리초 값을 UTC(협정 세계시) 시각으로 변환
	- UTC : Apr 09 2020 16:51:31UTC

- 41비트로 표현할 수 있는 타임스탬프의 최대값 : 2^41-1 -> 69년 동안만 정상 동작한다.
- 오버플로가 발생하는 시점, 69년이 지나면 기원 시각을 바꾸거나 ID 체계를 이전해야 한다.

일련번호
- 2^12 = 4096개 값 만들 수 있다.
- 서버가 같은 밀리초 안에 하나 이상의 ID를 만들어야만 0보다 큰 일련번호값을 갖게 된다.

## 4단계. 마무리
추가적으로 고민해볼 사항
- 시계 동기화 : 만약 하나의 서버가 여러 코어에서 실행되거나 여러 서버가 물리적으로 독립된 여러 장비에서 실행된다면?
	- NTP(Network Time Protocol) 이 가장 보편적인 수단
- 각 section 길이 *최적화* : 동시성이 낮고, 수명이 긴 애플리케이션이라면?
	- 일련번호 section의 길이를 줄이고, 타임스탬프 section의 길이를 늘려서 69년 이상 시점에 오버플로우가 발생하도록 할 수 있겠다.
- 고가용성(high availability) : ID 생성기는 필수 불가결한 컴포넌트이므로 고민 필요하다.
